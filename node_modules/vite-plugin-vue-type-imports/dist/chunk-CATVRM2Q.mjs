import{parse as Se}from"@vue/compiler-sfc";import le from"fs";import{existsSync as te,readFileSync as ne}from"fs";import{dirname as v,extname as re,join as F}from"path";import ae from"fast-glob";import{resolveModule as ie}from"local-pkg";import{babelParse as oe}from"@vue/compiler-sfc";function D(e){return oe(e,{sourceType:"module",plugins:["typescript","topLevelAwait"]}).program}function se(e,n){if(e instanceof RegExp)return e.test(n);if(n.length<e.length)return!1;if(n===e)return!0;let a=n.indexOf(e)===0,r=n.slice(e.length)[0]==="/";return a&&r}function pe(e){let n;for(;;){if(!e)return;let a=v(e);if(a===e)return;if(e=a,n=F(e,"package.json"),te(n))break}return n}function ce(e,n,a){let r=a==null?void 0:a.find(o=>se(o.find,e));if(r)return e.replace(r.find,r.replacement);let t=ie(e==="."?"./index":e);if(!t)return F(v(n),e);if(re(t)===".ts")return t;{let o=pe(t);if(!o)return;let{types:l,typings:g}=JSON.parse(ne(o,"utf-8")),c;try{c=F(v(o),l||g)}catch{}return c}}async function _(e,n,a){var o;let r=(o=ce(e,n,a))==null?void 0:o.replace(/\\/g,"/");if(!r)return null;let t=await ae([`${r}`,`${r}*.+(ts|d.ts)`,`${r}*/index.+(ts|d.ts)`],{onlyFiles:!0});return t.length?t[0]:null}function j(e){return e.reduce((n,a)=>(n[a.path]=n[a.path]||[],n[a.path].push(a.imported),n),{})}function G(e,n){let a=new Set(n);return[...new Set(e)].filter(r=>a.has(r))}function W(e,n,a=!1){n.sort((t,o)=>o.start-t.start);let r=e;for(let t of n)r=r.slice(0,t.start)+t.replacement+r.slice(t.end);return a&&(r=r.split(`
`).filter(t=>t).join(`
`)),r}function z(e,n,a){return e.slice(0,n)+a+e.slice(n)}var fe="defineProps",ye="defineEmits",me="withDefaults",ue=["TSTypeAliasDeclaration","TSInterfaceDeclaration","TSEnumDeclaration"],J=e=>O(e,fe),K=e=>O(e,ye),V=e=>O(e,me);function de(e){let n=[],a=[],r=t=>{for(let o of t.specifiers)o.type==="ImportSpecifier"&&o.imported.type==="Identifier"&&n.push({start:o.imported.start,end:o.local.end,imported:o.imported.name,local:o.local.name,path:t.source.value});a.push(t)};for(let t of e.body)t.type==="ImportDeclaration"&&t.specifiers.length&&r(t);return{imports:n,importNodes:a}}function Te(e){let n=[],a=r=>{for(let t of r.specifiers)t.type==="ExportSpecifier"&&t.exported.type==="Identifier"&&n.push({start:t.exported.start,end:t.local.end,imported:t.exported.name,local:t.local.name,path:r.source.value})};for(let r of e.body)xe(r)&&a(r);return n}function q(e){let n=[],a=r=>{var t;if(r.type==="CallExpression"&&((t=r.typeParameters)==null?void 0:t.type)==="TSTypeParameterInstantiation"){let o=r.typeParameters.params[0];o.type==="TSTypeReference"&&o.typeName.type==="Identifier"&&n.push(o.typeName.name)}};for(let r of e.body)if(r.type==="ExpressionStatement"&&(V(r.expression)?a(r.expression.arguments[0]):(J(r.expression)||K(r.expression))&&a(r.expression)),r.type==="VariableDeclaration"&&!r.declare)for(let t of r.declarations)t.init&&(V(t.init)?a(t.init.arguments[0]):(J(t.init)||K(t.init))&&a(t.init));return n}function ge(e,n){return e.body.map(a=>a.type==="ExportNamedDeclaration"&&a.declaration&&Y(a.declaration,n)?a.declaration:Y(a,n)?a:null).filter(a=>a!==null)}async function w(e,n,a){let{relativePath:r,aliases:t,ast:o=D(e),isInternal:l=!1,cleanInterface:g=!1,extractedTypes:c=new Map,metaDataMap:x=new Map}=a,S=[],{imports:A,importNodes:I}=de(o);l||A.push(...Te(o));let M=N(ge(o,l)),R=[],f=[],b=(i,s)=>H(i)&&H(s)?e.slice(i,s):"";function h(i){f.push({start:i.start,end:i.end,replacement:""})}function N(i){let s=new Map;for(let p of i)"name"in p.id&&s.set(p.id.name,p);return s}function u(i){switch(i.type){case"TSTypeAliasDeclaration":{Z(i);break}case"TSInterfaceDeclaration":{X(i);break}case"TSEnumDeclaration":{ee(i);break}}}function m(i){if(c.get(i))return;let s=M.get(i);s?u(s):S.push(i)}let C=async(i,s)=>{let p=await _(i,r,t);if(!p)return;let y=le.readFileSync(p,"utf-8");await w(y,s,{relativePath:p,aliases:t,extractedTypes:c,metaDataMap:x})},E=i=>{i.types.filter(s=>s.type==="TSTypeReference").forEach(s=>{s.typeName.type==="Identifier"&&m(s.typeName.name)})};function L(i,s){for(let p of i)if(p.expression.type==="Identifier"){let y=p.expression.name;x.set(y,s),l&&R.push(y),m(y)}}let X=i=>{var $,U;let{extendInterfaceName:s,interfaceBodyStart:p,isProperty:y}=x.get(i.id.name)??{},d=i.id.name,P=i.extends;if(y){c.set(d,`interface ${d} {}`);return}let k=i.body.start,B=i.body.end;s?(c.set(s,z(c.get(s),p+1,b(k+1,B-1))),l&&g&&h(i),P&&L(P,{extendInterfaceName:s,interfaceBodyStart:p})):(c.set(d,`interface ${d} ${b(k,B)}`),P?(l&&h(i),L(P,{extendInterfaceName:d,interfaceBodyStart:d.length+11})):l&&c.delete(d));for(let T of i.body.body)T.type==="TSPropertySignature"&&((($=T.typeAnnotation)==null?void 0:$.typeAnnotation.type)==="TSUnionType"?E(T.typeAnnotation.typeAnnotation):((U=T.typeAnnotation)==null?void 0:U.typeAnnotation.type)==="TSTypeReference"&&T.typeAnnotation.typeAnnotation.typeName.type==="Identifier"&&(x.set(T.typeAnnotation.typeAnnotation.typeName.name,{isProperty:!0}),m(T.typeAnnotation.typeAnnotation.typeName.name)))},Z=i=>{c.set(i.id.name,b(i.start,i.end)),i.typeAnnotation.type==="TSUnionType"&&E(i.typeAnnotation),i.typeAnnotation.type==="TSTypeReference"&&i.typeAnnotation.typeName.type==="Identifier"&&m(i.typeAnnotation.typeName.name)},ee=i=>{let s=i.id.name,p=new Set;for(let y of i.members)y.initializer?y.initializer.type==="NumericLiteral"?p.add("number"):y.initializer.type==="StringLiteral"&&p.add("string"):p.add("number");c.set(s,`type ${s} = ${[...p].join(" | ")||"number | string"};`)};for(let i of n)m(i);return S.length&&await Promise.all(Object.entries(j(A)).map(async([i,s])=>{let p=G(s,S);p.length&&await C(i,p)})),{result:c,importNodes:I,extraSpecifiers:R,extraReplacements:f}}function H(e){return typeof e=="number"}function O(e,n){return!!(e&&e.type==="CallExpression"&&e.callee.type==="Identifier"&&(typeof n=="string"?e.callee.name===n:n(e.callee.name)))}function Y(e,n){return n?!!(e&&e.type==="TSInterfaceDeclaration"):!!(e&&ue.includes(e.type))}function xe(e){return!!(e&&e.type==="ExportNamedDeclaration"&&e.source)}async function Q(e,{id:n,aliases:a,clean:r}){let{descriptor:{scriptSetup:t}}=Se(e);if((t==null?void 0:t.lang)!=="ts"||!t.content)return e;let o=D(t.content),l=q(o),{result:g,importNodes:c,extraSpecifiers:x,extraReplacements:S}=await w(t.content,l,{aliases:a,relativePath:n,ast:o,isInternal:!0,cleanInterface:r.interface});if(!g.size)return e;let A=[...g].reverse(),I=S;c.forEach(f=>{let b=f.specifiers[0].start,h=f.specifiers[f.specifiers.length-1].end,N=f.specifiers.map(u=>{if(u.type==="ImportSpecifier"&&u.imported.type==="Identifier"){let m=u.imported.name;return!A.some(E=>E[0]===m)&&!x.includes(m)?m:null}return null}).filter(u=>u!==null);N.length?I.push({start:b,end:h,replacement:N.join(", ")}):I.push({start:f.start,end:f.end,replacement:""})});let M=A.map(f=>f[1]).join(`
`);return[e.slice(0,t.loc.start.offset),M,W(t.content,I,r.newline),e.slice(t.loc.end.offset)].join(`
`)}function Ae(e={}){let n=e.clean??{},a;return{name:"vite-plugin-vue-type-imports",enforce:"pre",async configResolved(r){a=r},async transform(r,t){if(!/\.(vue)$/.test(t))return;let o=a==null?void 0:a.resolve.alias;return{code:await Q(r,{id:t,aliases:o,clean:n})}}}}export{Ae as a};
